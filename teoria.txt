COMPILAZIONE ED ESECUZIONE DA CMD
compilazione java:
    javac Esempio1.java       (produce Esempio1.class)
poi per farlo partire:
    java Esempio1 (args)

per distribuire i programmi, java utilizza il tipo .jar che è un file compresso ZIP che contiene al suo
interno tutto il programma (essendo diviso in classi andava trovato un altro modo)

per creare un file .jar come archivio di classi (zip):
    jar cf nomearchivio.jar classi -> è un elenco di classi da scrivere oppure un'intera da cartella.
                                      vanno separate tutte da ;
    ESEMPIO:
    jar cf nomeCheScelgoIo.jar *.class;pippo/*.class -> andrà a creare nomeCheScelgoIo.jar con le classi
                                                        .class che ho incluso

per creare un file .jar eseguibile:
    jar cmf info.txt nomeapp.jar classi -> classi esattamente come prima
    info.txt è un file che contiene la riga:
        Main-Class: NomeclasseMain -> seguita da una riga vuota INDISPENSABILE

TIPI PRIMITIVI
per conversione di tipi primitivi in java si usa il CAST:
    float f = (float) 3.54;     oppure     float f = 3.54F; -> ques'ultimo non è cast ma direttamente
                                                               l'input giusto

i caratteri in java ovviamente non seguono più la tabella ASCII che ha pochissimi caratteri,
ma UTF-8, UTF-16 e UTF-32






Date
Per tutte le cose che hanno a che fare con il tempo si importa la libreria java.time.*

Questa libreria non utilizza il termine 'new', ma ha un costruttore proprio che è '.of'.
Per esempio si scrive:
    LocalDate natale = LocalDate.of(2020, 12, 25);
Oppure per mesi e giorni della settimana (ENUM) si scrive:
    Month mese = Month.of(10) --> OCTOBER
    DayOfWeek giorno = DayOfWeek.of(2) --> TUESDAY
Oppure per orari locali:
    LocalTime mezzogiorno = LocalTime.of(12, 00)

I vari concetti sono:
    locali:
        LocalDate
        LocalTime
        LocalDateTime
        Period --> durata relativa
    assoluti:
        Instant
        Duration
        OffsetDateTime --> data assoluta sulla linea del tempo espressa come data + orario + delta rispetto a Greenwich (UTC)
        ZonedDateTime --> data assoluta sulla linea del tempo espressa come data + orario + delta rispetto a Greenwich (UTC)

GIORNI E MESI
I due enumerativi per giorni e mesi:
    Month
    DayOfWeek
Entrambi hanno un getValue che dall'enum restituiscono il numero:
    Month.OCTOBER.getValue() --> 10
    DayOfWeek.MONDAY.getValue() --> 1
Oppure hanno la funzione '.of' che restituisce la costante enumerativa del numero (il contrario di prima):
    Month.of(10) --> OCTOBER
    DayOfWeek.of(1) --> MONDAY

DATE E ORARI LOCALI
    da struttura LocalDate posso ottenere i vari valori con:
        getDayOfMonth
        getMonth
        getYear
        getDayOfYear
        getDayOfWeek
        isLeapYear
        ...
    da struttura LocalTime posso utilizzare invece:
        getHour
        getMinute
        getSecond
        getNano
Posso aggiungere, sottrarre o modificare alcuni parametri con:
    per LocalDate:
        plus*:
            natale2020.plusYears(4) --> natale2024
        minus*:
            allo stesso modo
        with*:
            natale2020.withYear(2018) --> natale2018
    per LocalTime:
        stessa roba

PERIOD
Un periodo che non è però di un "luogo temporale specifico".
Posso dire infatti un periodo di un mese, ma non tutti i mesi hanno la stessa durata, quindi
fa comodo non sapere di che mese si stia parlando.

Anche in questo caso ci sono il costruttore '.of' e le varie funzioni plus, minus, between, ...
    Period p1 = Period.ofMonths(2).plusDays(3)

Per unire Period alle varie date locali o assolute, ci sono funzioni come:
    addTo:
        LocalDate d1 = (LocalDate)p1.addTo(xmas2017); --> OCCHIO AL CAST
    substractFrom:
        stessa roba

INSTANT
Praticamente inutile, ha il suo costruttore e può essere utile perché disconnesso da calendari specifici
per cultura.

Esempio per istante attuale:
    Instant adesso = Instant.now();

DURATION
La durata di tempo tra due istanti
    Duration d = Duration.between(i1,i2)

Come sempre c'è il '.of' e i vari plus, minus, with e between.

Ci sono anche metodi che possono convertire durate in anni, mesi giorni, ore, minuti, ... --> TRONCAMENTO

ORARI E DATE ASSOLUTE
guarda diapositive da 27 ppt Date



FORMATTATORI
Non in tutte le culture vengono formattati i dati in modo uguale. Java offre dei formattatori a seconda delle varie culture in alcuni database.
La libreria che rappresenta il concetto di culura locale è java.util.Locale
Ogni cultura è rappresentata con lingua con 2 minuscole e paese con due maiuscole.
	it_IT oppure en_GB
Se non si specifica nulla i formattatori adottano il default della macchina che si può vedere attraverso 'Locale.getDefault'

Esistono due grandi famiglie di formattatori:
	formattatori NUMERICI (java.text.NumberFormat)
		formattazione di numeri
		formattazione di percentuali
		formattazione di prezzi e valori di valute

		formatter.format(valore) --> il formattatore è dichiarato in NumberFormat

	formattatori per DATE e ORARI (java.time.format.DateTimeFormatter)
		formattazione di data (in 4 formati: breve, medio, lungo e full)
		formattazione di orario (in 2 formati: breve e medio)
		formattazione di una data con orario (4 x 2 formati)

		valore.format(formatter) --> il formattatore è dichiarato in LocalDate

FORMATTATORI NUMERICI
Nella classe NumberFormat ci sono 3 metodi get che fungono da factory
	Esempio:
		double x = 43.12345678, y = 0.7, z = 13456.78;
		NumberFormat fN = NumberFormat.getNumberInstance();
		NumberFormat fP = NumberFormat.getPercentInstance();
		NumberFormat fV = NumberFormat.getCurrencyInstance();
		
		fN.setMaximumFractionDigits(2); --> configurazione
		System.out.println( fN.format(x) ); --> 43,12
		System.out.println( fN.format(y) ); --> 0,7
		System.out.println( fN.format(z) ); --> 13.456,78
		
		fP.setMaximumFractionDigits(2);
		System.out.println( fP.format(x) ); --> 43,12%
		System.out.println( fP.format(y) ); --> 70%
		System.out.println( fP.format(z) ); --> 123,46%

		System.out.println( fV.format(z) ); --> 1.243,57 € (fino a Java 8 il simbolo dell'euro era prima del valore, quindi occhio a retrocompatibilità)

I formattatori numerici supportano anche il parsing, che converte una stringa numerica in un tipo Number, che può essere utilizzato come double, float o int a piacere.
Deve ovviamente essere correttamente formattata secondo le regole di una cultura locale.
Va però saputa usare la gestione degli errori, sennò il programma non compila, quindi c'è da aspettare

FORMATTATORI PER DATE E ORARI
I metodi factory sono di nuovo gli 'of**(...)'. Invertono il pattern d'uso: dataora.format(formatter).
Ci sono 4 formati di stile per le date:
	SHORT: gg/mm/aa
	MEDIUM: gg siglamese aaaa
	LONG: gg mese aaaa
	FULL giorno gg mese aaaa
	
	Esempio:
		DateTimeFormatter formatterShort = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
		DateTimeFormatter formatterMedium = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);
		DateTimeFormatter formatterLong = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);
		DateTimeFormatter formatterFull = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
		LocalDate d = LocalDate.now();
		System.out.println(d.format(formatterShort)); --> 04/03/20
		System.out.println(d.format(formatterMedium)); --> 4 mar 2020
		System.out.println(d.format(formatterLong)); --> 4 marzo 2020
		System.out.println(d.format(formatterFull)); --> mercoledì 4 marzo 2020

Sennò formattatori personalizzati con il metodo factory 'ofPattern':
	Esempio:
		DateTimeFormatter myFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
		LocalDate d = LocalDate.now();
		System.out.println(d.format(myFormatter)); --> 04/03/2020

Il Locale se non vogliamo quello default viene passato con il metodo 'withLocale(Locale.*)'
	Esempio:
		DateTimeFormatter.ofLocalizedDate(…).withLocale(Locale.CANADA)

I formattatori per gli orari sono uguali a quelli per le date ma hanno solo due formati:
	SHORT: hh:mm
	MEDIUM: hh:mm:ss

	Esempio:
		DateTimeFormatter formatterShort = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
		DateTimeFormatter formatterMedium = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM);
		LocalTime t = LocalTime.now();
		System.out.println(t.format(formatterShort)); --> 18:37
		System.out.println(t.format(formatterMedium)); --> 18:37:41

Per formattatori che vogliono sia le date che l'orario si usa il metodo '.ofLocalizedDateTime(dateStyle, timeStyle)'.





RECORD

record ===> contenitori di valori.

Si inizializzano così:
record Puppa(int numero, String nome) {}

utili perché il compilatore crea in automatico il costruttore e i get. Per esempio posso usare nel caso precedente getNumero() o getNome() senza scriverlo io manualmente.

Posso anche aggiungere dei metodi personalizzati ma ATTENZIONE: i valori dei record sono IMMUTABILI, quindi non posso creare un metodo così:
record Puppa(int numero, String nome) {
	public void setNumero(int nuovoNumero) {
		this.numero = nuovoNumero;
	}
}

Il compilatore darebbe errore, non posso cambiare il valore dei dati, l'unica cosa che posso fare è creare un nuovo record che restituisco, ma è un record diverso

record Puppa(int numero, String nome) {
	public Puppa setNumero(int nuovoNumero) {
		return new Puppa(nuovoNumero, nome);
	}
}

Utile però per avere vari metodi get che ritornano magari valori modificati dei dati presenti all'interno.





CLASSI ASTRATTE

classi che possono avere dei metodi astratti che non vengono inizialmente implementati o vengono implementati con un metodo di default poiché
ogni SOTTOCLASSE avrà il suo specifico.

le classi astratte si creano così:

public class abstract Puppa {
	private int numero = 0;
	private String nome = null;

	public Puppa(int numero, String nome) {
		this.numero = numero;
		this.nome = nome;
	}

	public void metodo1() {
		bla;
		bla;
	}

	public void metodoAstratto();

	public void metodoAstratto2() {
		bla;
		bla;
		implementazione default, poi in ogni sottoclasse ci sarà un metodo chiamato nello stesso modo con @Override prima e il compilatore nel caso in cui esista;
		utilizzerà quello;
	}
}

Ogni sottoclasse dorvà essere creata specificando che estende la classe astratta, per esempio:

public class DaiCheAndiamo extends Puppa{
    private String sesso;

    public DaiCheAndiamo(int numero, String nome, String sesso) {
        super(numero, nome);
        this.sesso = sesso;
    }

    @Override
    public void metodoAstratto() {
        bla; bla;
    }

    @Override
    public void metodoAstratto2() {
        bla; bla;
    }
}

La sottoclasse DEVE avere un costruttore che inizializza tutti i dati, per inizializzare i dati della classe astratta al di sopra si utilizza la funzione super()
con i dati all'interno che indica che richiama il costruttore della classe astratta e inserisce i dati all'interno di essa.




